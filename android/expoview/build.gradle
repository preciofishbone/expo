apply plugin: 'com.android.library'
apply plugin: 'kotlin-android'
apply plugin: 'maven-publish'
apply plugin: 'de.undercouch.download'
apply plugin: 'kotlin-kapt'
apply from: new File(rootDir, "versioning_linking.gradle")

// WHEN_VERSIONING_REMOVE_FROM_HERE
//maven repository info
group = 'host.exp.exponent'
version = '45.0.0'

// Creating sources with comments
task androidSourcesJar(type: Jar) {
  classifier = 'sources'
  from android.sourceSets.main.java.srcDirs
}

afterEvaluate {
  publishing {
    publications {
      // use `versionedRelease` configuration when publishing to maven
      versionedRelease(MavenPublication) {
        from components.versionedRelease
        // Add additional sourcesJar to artifacts
        artifact(androidSourcesJar)
      }
    }
    repositories {
      maven {
        url = mavenLocal().url
      }
    }
  }
}
// WHEN_VERSIONING_REMOVE_TO_HERE

// WHEN_PREPARING_REANIMATED_REMOVE_FROM_HERE

// reanimated

def debugNativeLibraries = false

import java.nio.file.Paths

import de.undercouch.gradle.tasks.download.Download
import org.apache.tools.ant.taskdefs.condition.Os
import org.apache.tools.ant.filters.ReplaceTokens

def reactProperties = new Properties()
def reactNative = new File("$projectDir/../../versioned-react-native")

// WHEN_VERSIONING_REMOVE_FROM_HERE
reactNative = new File("$projectDir/..")
// WHEN_VERSIONING_REMOVE_TO_HERE

file("$reactNative/ReactAndroid/gradle.properties").withInputStream { reactProperties.load(it) }

def BOOST_VERSION = reactProperties.getProperty("BOOST_VERSION")
def DOUBLE_CONVERSION_VERSION = reactProperties.getProperty("DOUBLE_CONVERSION_VERSION")
def FOLLY_VERSION = reactProperties.getProperty("FOLLY_VERSION")
def GLOG_VERSION = reactProperties.getProperty("GLOG_VERSION")
def REACT_VERSION = reactProperties.getProperty("VERSION_NAME").split("\\.")[1].toInteger()
def REACT_NATIVE_PATH = reactNative.absolutePath
def CMAKE_OUTPUT_DIR = "$buildDir/reanimated-ndk/all"
def RN_SO_DIR = "$reactNative/ReactAndroid/build/intermediates/library_*/*/jni"
def FBJNI_HEADERS_DIR = "$reactNative/ReactAndroid/src/main/jni/first-party/fbjni/headers"
def FOR_HERMES = false
def reactNativeArchitectures() {
    def value = project.getProperties().get("reactNativeArchitectures")
    return value ? value.split(",") : ["armeabi-v7a", "x86", "x86_64", "arm64-v8a"]
}

def prebuiltHermesDir = findProperty("expo.prebuiltHermesDir") ?: file("${project(':ReactAndroid').projectDir}/prebuiltHermes")
def prebuiltHermesVersion = file("${prebuiltHermesDir}/.hermesversion").exists() ? file("${prebuiltHermesDir}/.hermesversion").text : null
def currentHermesVersion = file("${rootDir}/sdks/.hermesversion").exists() ? file("${rootDir}/sdks/.hermesversion").text : null
def buildHermesSource = currentHermesVersion != prebuiltHermesVersion
logger.info(":expoview - buildHermesSource[${buildHermesSource}]")

// WHEN_PREPARING_REANIMATED_REMOVE_TO_HERE


buildscript {
  // Simple helper that allows the root project to override versions declared by this library.
  ext.safeExtGet = { prop, fallback ->
    rootProject.ext.has(prop) ? rootProject.ext.get(prop) : fallback
  }

  repositories {
    // If you have maven { url "https://jitpack.io" } as your resolving url,
    // then Jitpack will only return the POM for the Android dependency causing the Gradle sync to fail.
    // However, when you change url to "https://www.jitpack.io", Jitpack returns POM, AAR, and sources.jar.
    // That is why we were adding www even though jitpacks docs don't say so.
    // See https://github.com/jitpack/jitpack.io/issues/4002.
    maven { url "https://www.jitpack.io" }
    mavenCentral()
    google()
  }
  dependencies {
    classpath("org.jetbrains.kotlin:kotlin-gradle-plugin:${safeExtGet('kotlinVersion', '1.6.10')}")
  }
}

repositories {
  maven { url "https://www.jitpack.io" }
  mavenCentral()
}

android {
  compileSdkVersion safeExtGet("compileSdkVersion", 31)

  // Used to override the NDK path/version on internal CI or by allowing
  // users to customize the NDK path/version from their root project (e.g. for M1 support)
  if (rootProject.hasProperty("ndkPath")) {
    ndkPath rootProject.ext.ndkPath
  }
  if (rootProject.hasProperty("ndkVersion")) {
    ndkVersion rootProject.ext.ndkVersion
  }

  compileOptions {
    sourceCompatibility JavaVersion.VERSION_11
    targetCompatibility JavaVersion.VERSION_11
  }

  kotlinOptions {
    jvmTarget = JavaVersion.VERSION_11.majorVersion
  }

  buildFeatures {
    viewBinding true
  }

  defaultConfig {
    minSdkVersion safeExtGet("minSdkVersion", 21)
    targetSdkVersion safeExtGet("targetSdkVersion", 31)
    versionCode 1
    versionName "1.0"

    /* WHEN_VERSIONING_UNCOMMENT_FROM_HERE
    missingDimensionStrategy('versioning', 'versioned')
    WHEN_VERSIONING_UNCOMMENT_TO_HERE */

    // WHEN_VERSIONING_REMOVE_FROM_HERE
    manifestPlaceholders = [
        'appAuthRedirectScheme': 'host.exp.exponent'
    ]
    // WHEN_VERSIONING_REMOVE_TO_HERE

    // WHEN_PREPARING_REANIMATED_REMOVE_FROM_HERE
    externalNativeBuild {
      cmake {
        arguments "-DANDROID_STL=c++_shared",
            "-DREACT_NATIVE_TARGET_VERSION=${REACT_VERSION}",
            "-DANDROID_TOOLCHAIN=clang",
            "${getCmakeToolchainFile()}",
            "-DBOOST_VERSION=${BOOST_VERSION}",
            "-DFOR_HERMES=${FOR_HERMES}",
            "-DREACT_NATIVE_PATH=${REACT_NATIVE_PATH}",
            "-DRN_SO_DIR=${RN_SO_DIR}",
            "-DFBJNI_HEADERS_DIR=${FBJNI_HEADERS_DIR}",
            "-DCMAKE_OUTPUT_DIR=${CMAKE_OUTPUT_DIR}"
        abiFilters (*reactNativeArchitectures())
      }
    }

    buildConfigField("boolean", "IS_INTERNAL_BUILD", "false")
    buildConfigField("int", "EXOPACKAGE_FLAGS", "0")
    buildConfigField("boolean", "IS_NEW_ARCHITECTURE_ENABLED", "false")
    // WHEN_PREPARING_REANIMATED_REMOVE_TO_HERE
  }

  // WHEN_PREPARING_REANIMATED_REMOVE_FROM_HERE
  externalNativeBuild {
    cmake {
      path "CMakeLists.txt"
    }
  }

  packagingOptions {
    println "Native libs debug enabled: ${debugNativeLibraries}"
    doNotStrip debugNativeLibraries ? "**/**/*.so" : ''

    // Gradle will add cmake target dependencies into packaging.
    // Theses files are intermediated linking files to build reanimated and should not be in final package.
    excludes = [
      "**/libc++_shared.so",
      "**/libreactnativejni.so",
      "**/libglog.so",
      "**/libjscexecutor.so",
      "**/libfbjni.so",
      "**/libfolly_runtime.so",
      "**/libhermes.so",
      "**/libjsi.so",
    ]
  }

  configurations {
    extractHeaders
    extractSO
  }
  // WHEN_PREPARING_REANIMATED_REMOVE_TO_HERE

  buildTypes {
    release {
      consumerProguardFiles('proguard-rules.pro')
    }
  }

  // WHEN_VERSIONING_REMOVE_FROM_HERE
  flavorDimensions "versioning"
  productFlavors {
    versioned {
      dimension "versioning"
    }
    unversioned {
      getIsDefault().set(true)
      dimension "versioning"
    }
  }
  // WHEN_VERSIONING_REMOVE_TO_HERE

  // use `versionedRelease` configuration when publishing to maven
  defaultPublishConfig "versionedRelease"
}

// WHEN_VERSIONING_REMOVE_FROM_HERE
import org.apache.tools.ant.taskdefs.condition.Os

class GenerateDynamicMacrosPlugin implements Plugin<Project> {
  @Override
  void apply(org.gradle.api.Project target) {
    target.exec {
      def configuration = target.gradle.startParameter.taskNames.any {
        it.toLowerCase().contains("release")
      } ? "release" : "debug"

      workingDir '../../bin'

      if (Os.isFamily(Os.FAMILY_WINDOWS)) {
        commandLine 'cmd.exe', '/c', "expotools android-generate-dynamic-macros --configuration ${configuration}"
      } else {
        commandLine "./expotools", "android-generate-dynamic-macros", "--configuration", configuration
      }
    }
  }
}

apply plugin: GenerateDynamicMacrosPlugin

configurations.all {
  resolutionStrategy {
    force 'org.webkit:android-jsc:r245459'
  }
}

// WHEN_VERSIONING_REMOVE_TO_HERE

dependencies {
  api fileTree(dir: 'libs', include: ['*.jar'])
  api 'androidx.multidex:multidex:2.0.0'
  implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlinVersion"
  implementation "org.jetbrains.kotlin:kotlin-reflect:$kotlinVersion"

  testImplementation 'junit:junit:4.12'


  api("com.facebook.fbjni:fbjni-java-only:0.2.2")

  // WHEN_PREPARING_REANIMATED_REMOVE_FROM_HERE

  extractHeaders("com.facebook.fbjni:fbjni:0.2.2:headers")
  extractSO("com.facebook.fbjni:fbjni:0.2.2")

  // WHEN_PREPARING_REANIMATED_REMOVE_TO_HERE

  // WHEN_VERSIONING_REPLACE_WITH_DEPENDENCIES

  // WHEN_VERSIONING_REMOVE_FROM_HERE

  api 'org.webkit:android-jsc:r245459' // needs to be before react-native

  /* UNCOMMENT WHEN DISTRIBUTING
  api 'com.facebook.react:react-native:45.0.0'
  compileOnly project(':expo')
  compileOnly project(':expo-random')
  END UNCOMMENT WHEN DISTRIBUTING */

  // WHEN_DISTRIBUTING_REMOVE_FROM_HERE
  api project(':ReactAndroid')

  if (!buildHermesSource) {
    debugImplementation(files("${prebuiltHermesDir}/hermes-engine-debug.aar"))
    releaseImplementation(files("${prebuiltHermesDir}/hermes-engine-release.aar"))
  } else {
    implementation(project(':ReactAndroid:hermes-engine')) {
      exclude(group:'com.facebook.fbjni', module: 'fbjni')
    }
  }

  // Expo modules
  api project(':expo')

  // expo-random is no longer a unimodule
  api project(':expo-random')

  // Versioned react native
  // WHEN_PREPARING_SHELL_REMOVE_FROM_HERE
  // THIS COMMENT IS USED BY android-build-aar.sh DO NOT MODIFY
  // BEGIN_SDK_46
  versionedApi 'host.exp:reactandroid-abi46_0_0:1.0.0'
  // END_SDK_46
  // BEGIN_SDK_45
  versionedApi 'host.exp:reactandroid-abi45_0_0:1.0.0'
  // END_SDK_45
  // BEGIN_SDK_44
  versionedApi 'host.exp:reactandroid-abi44_0_0:1.0.0'
  // END_SDK_44
  // WHEN_PREPARING_SHELL_REMOVE_TO_HERE
  // WHEN_VERSIONING_REMOVE_TO_HERE
  // WHEN_DISTRIBUTING_REMOVE_TO_HERE

  // React native dependencies
  api 'androidx.appcompat:appcompat:1.2.0'
  api 'androidx.autofill:autofill:1.1.0'
  api 'androidx.swiperefreshlayout:swiperefreshlayout:1.0.0'
  api 'com.facebook.fbjni:fbjni-java-only:0.2.2'
  api 'com.facebook.fresco:fresco:2.5.0'
  api 'com.facebook.fresco:animated-gif:2.5.0'
  api 'com.facebook.fresco:animated-webp:2.5.0'
  api 'com.facebook.fresco:webpsupport:2.5.0'
  api 'com.facebook.fresco:imagepipeline-okhttp3:2.5.0'
  api 'com.facebook.fresco:ui-common:2.5.0'
  api 'com.facebook.infer.annotation:infer-annotation:0.18.0'
  api 'com.facebook.soloader:soloader:0.10.3'
  api 'com.facebook.yoga:proguard-annotations:1.19.0'
  api 'com.google.code.findbugs:jsr305:3.0.2'
  api 'com.squareup.okhttp3:okhttp-urlconnection:4.9.2'
  api 'com.squareup.okhttp3:okhttp:4.9.2'
  api 'com.squareup.okio:okio:2.9.0'
  api 'javax.inject:javax.inject:1'

  // Our dependencies
  compileOnly 'org.glassfish:javax.annotation:3.1.1'
  api 'de.greenrobot:eventbus:2.4.0'
  api "androidx.room:room-runtime:2.1.0"

  api 'com.squareup.picasso:picasso:2.5.2'
  api 'com.google.android.gms:play-services-analytics:17.0.0'
  api 'com.google.android.gms:play-services-maps:18.0.0'
  api 'com.google.android.gms:play-services-auth:17.0.0'
  api 'com.google.android.gms:play-services-location:17.0.0'
  api 'com.google.android.gms:play-services-fitness:17.0.0'
  api 'com.google.android.gms:play-services-wallet:17.0.0' //may need 10.+
  debugApi 'com.squareup.leakcanary:leakcanary-android-no-op:1.4-beta1'
  // debugApi 'com.squareup.leakcanary:leakcanary-android:1.4-beta1'
  releaseApi 'com.squareup.leakcanary:leakcanary-android-no-op:1.4-beta1'
  api 'commons-io:commons-io:2.6'
  api 'me.leolin:ShortcutBadger:1.1.4@aar'
  implementation "com.github.CanHub:Android-Image-Cropper:4.3.0"
  api 'commons-codec:commons-codec:1.10'
  api 'net.openid:appauth:0.7.1'
  api 'com.airbnb.android:lottie:3.4.0'
  compileOnly 'io.branch.sdk.android:library:4.1.0'
  api "androidx.exifinterface:exifinterface:1.0.0"
  api "androidx.legacy:legacy-support-v4:1.0.0"
  api "androidx.browser:browser:1.0.0"

  // expo-face-detector
  implementation 'com.google.mlkit:face-detection:16.1.5'

  // expo-ads-admob
  implementation 'com.google.android.gms:play-services-ads:20.5.0'
  // For apps targeting Android 12, add WorkManager dependency.
  // See more at https://developers.google.com/admob/android/rel-notes
  constraints {
    implementation('androidx.work:work-runtime:2.7.0') {
      because '''androidx.work:work-runtime:2.1.0 pulled from
      play-services-ads has a bug using PendingIntent without
      FLAG_IMMUTABLE or FLAG_MUTABLE and will fail in Apps
      targeting S+.'''
    }
  }

  // react-native-screens
  api 'androidx.fragment:fragment:1.2.2'
  api 'androidx.coordinatorlayout:coordinatorlayout:1.1.0'
  api 'com.google.android.material:material:1.1.0'

  api 'com.google.firebase:firebase-core:17.2.3'
  api 'com.google.firebase:firebase-messaging:22.0.0'
  api 'com.google.maps.android:android-maps-utils:0.5'
  // Remember to update DetachAppTemplate build.gradle if you add any excludes or transitive = false here!

  // Used only in Expo Go, see Analytics.java
  compileOnly 'com.amplitude:android-sdk:2.23.2'

  // expo-file-system
  api 'com.squareup.okhttp3:okhttp:3.10.0'
  api 'com.squareup.okhttp3:okhttp-urlconnection:3.10.0'

  // expo-av
  // See explanation in expo-av/build.gradle
  api 'com.google.android.exoplayer:extension-okhttp:2.13.3'

  // expo-application
  api 'com.android.installreferrer:installreferrer:1.0'

  //dbflow
  kapt "com.github.Raizlabs.DBFlow:dbflow-processor:${safeExtGet('dbFlowVersion', '4.2.4')}"
  implementation "com.github.Raizlabs.DBFlow:dbflow-core:${safeExtGet('dbFlowVersion', '4.2.4')}"
  implementation "com.github.Raizlabs.DBFlow:dbflow:${safeExtGet('dbFlowVersion', '4.2.4')}"

  implementation 'com.cronutils:cron-utils:4.1.3'

  // @react-native-community/viewpager
  api 'com.github.troZee:ViewPager2:v1.0.6'

  // stripe-react-native
  implementation('com.stripe:stripe-android:20.5.+')
  implementation('com.stripe:financial-connections:20.5.+')
  implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.5.0'
  implementation "androidx.lifecycle:lifecycle-runtime-ktx:2.3.1"
  implementation 'com.google.android.material:material:1.3.0'

  // react-native-webview
  implementation "androidx.webkit:webkit:1.4.0"

  // expo-updates
  implementation 'org.bouncycastle:bcutil-jdk15to18:1.70'

  // react-native-maps
  implementation "androidx.work:work-runtime:2.7.1"
}

useVendoredModulesForExpoView('unversioned')

// WHEN_PREPARING_REANIMATED_REMOVE_FROM_HERE

// reanimated

// We download various C++ open-source dependencies into downloads.
// We then copy both the downloaded code and our custom makefiles and headers into third-party-ndk.
// After that we build native code from src/main/jni with module path pointing at third-party-ndk.

def downloadsDir = new File("$buildDir/downloads")
def thirdPartyNdkDir = new File("$buildDir/third-party-ndk")

def reactNativeThirdParty = new File("$reactNative/ReactAndroid/src/main/jni/third-party")

// You need to have following folders in this directory:
//   - boost_1_63_0
//   - double-conversion-1.1.6
//   - folly-deprecate-dynamic-initializer
//   - glog-0.3.5
def dependenciesPath = System.getenv("REACT_NATIVE_DEPENDENCIES")

// The Boost library is a very large download (>100MB).
// If Boost is already present on your system, define the REACT_NATIVE_BOOST_PATH env variable
// and the build will use that.
def boostPath = dependenciesPath ?: System.getenv("REACT_NATIVE_BOOST_PATH")

def follyReplaceContent = '''
  ssize_t r;
  do {
    r = open(name, flags, mode);
  } while (r == -1 && errno == EINTR);
  return r;
'''

task createNativeDepsDirectories {
  downloadsDir.mkdirs()
  thirdPartyNdkDir.mkdirs()
}

task downloadBoost(dependsOn: createNativeDepsDirectories, type: Download) {
  src("https://boostorg.jfrog.io/artifactory/main/release/${BOOST_VERSION.replace("_", ".")}/source/boost_${BOOST_VERSION}.tar.gz")
  onlyIfNewer(true)
  overwrite(false)
  dest(new File(downloadsDir, "boost_${BOOST_VERSION}.tar.gz"))
}

task prepareBoost(dependsOn: boostPath ? [] : [downloadBoost], type: Copy) {
  from(boostPath ?: tarTree(resources.gzip(downloadBoost.dest)))
  from("$reactNativeThirdParty/boost/Android.mk")
  include("Android.mk", "boost_${BOOST_VERSION}/boost/**/*.hpp", "boost/boost/**/*.hpp")
  includeEmptyDirs = false
  into("$thirdPartyNdkDir/boost")
  doLast {
    file("$thirdPartyNdkDir/boost/boost").renameTo("$thirdPartyNdkDir/boost/boost_${BOOST_VERSION}")
  }
}

task downloadDoubleConversion(dependsOn: createNativeDepsDirectories, type: Download) {
  src("https://github.com/google/double-conversion/archive/v${DOUBLE_CONVERSION_VERSION}.tar.gz")
  onlyIfNewer(true)
  overwrite(false)
  dest(new File(downloadsDir, "double-conversion-${DOUBLE_CONVERSION_VERSION}.tar.gz"))
}

task prepareDoubleConversion(dependsOn: dependenciesPath ? [] : [downloadDoubleConversion], type: Copy) {
  from(dependenciesPath ?: tarTree(downloadDoubleConversion.dest))
  from("$reactNativeThirdParty/double-conversion/Android.mk")
  include("double-conversion-${DOUBLE_CONVERSION_VERSION}/src/**/*", "Android.mk")
  filesMatching("*/src/**/*", { fname -> fname.path = "double-conversion/${fname.name}" })
  includeEmptyDirs = false
  into("$thirdPartyNdkDir/double-conversion")
}

task downloadFolly(dependsOn: createNativeDepsDirectories, type: Download) {
  src("https://github.com/facebook/folly/archive/v${FOLLY_VERSION}.tar.gz")
  onlyIfNewer(true)
  overwrite(false)
  dest(new File(downloadsDir, "folly-${FOLLY_VERSION}.tar.gz"))
}

task prepareFolly(dependsOn: dependenciesPath ? [] : [downloadFolly], type: Copy) {
  from(dependenciesPath ?: tarTree(downloadFolly.dest))
  from("$reactNativeThirdParty/folly/Android.mk")
  include("folly-${FOLLY_VERSION}/folly/**/*", "Android.mk")
  eachFile { fname -> fname.path = (fname.path - "folly-${FOLLY_VERSION}/") }
  // Fixes problem with Folly failing to build on certain systems. See
  // https://github.com/software-mansion/react-native-reanimated/issues/1024
  filter { line -> line.replaceAll('return int\\(wrapNoInt\\(open, name, flags, mode\\)\\);', follyReplaceContent) }
  includeEmptyDirs = false
  into("$thirdPartyNdkDir/folly")
}

task downloadGlog(dependsOn: createNativeDepsDirectories, type: Download) {
  src("https://github.com/google/glog/archive/v${GLOG_VERSION}.tar.gz")
  onlyIfNewer(true)
  overwrite(false)
  dest(new File(downloadsDir, "glog-${GLOG_VERSION}.tar.gz"))
}

// Prepare glog sources to be compiled, this task will perform steps that normally should've been
// executed by automake. This way we can avoid dependencies on make/automake
task prepareGlog(dependsOn: dependenciesPath ? [] : [downloadGlog], type: Copy) {
  duplicatesStrategy("warn")
  from(dependenciesPath ?: tarTree(downloadGlog.dest))
  from("$reactNativeThirdParty/glog/")
  include("glog-${GLOG_VERSION}/src/**/*", "Android.mk", "config.h")
  includeEmptyDirs = false
  filesMatching("**/*.h.in") {
    filter(ReplaceTokens, tokens: [
        ac_cv_have_unistd_h           : "1",
        ac_cv_have_stdint_h           : "1",
        ac_cv_have_systypes_h         : "1",
        ac_cv_have_inttypes_h         : "1",
        ac_cv_have_libgflags          : "0",
        ac_google_start_namespace     : "namespace google {",
        ac_cv_have_uint16_t           : "1",
        ac_cv_have_u_int16_t          : "1",
        ac_cv_have___uint16           : "0",
        ac_google_end_namespace       : "}",
        ac_cv_have___builtin_expect   : "1",
        ac_google_namespace           : "google",
        ac_cv___attribute___noinline  : "__attribute__ ((noinline))",
        ac_cv___attribute___noreturn  : "__attribute__ ((noreturn))",
        ac_cv___attribute___printf_4_5: "__attribute__((__format__ (__printf__, 4, 5)))"
    ])
    it.path = (it.name - ".in")
  }
  into("$thirdPartyNdkDir/glog")

  doLast {
    copy {
      from(fileTree(dir: "$thirdPartyNdkDir/glog", includes: ["stl_logging.h", "logging.h", "raw_logging.h", "vlog_is_on.h", "**/src/glog/log_severity.h"]).files)
      includeEmptyDirs = false
      into("$thirdPartyNdkDir/glog/exported/glog")
    }
  }
}

task downloadNdkBuildDependencies {
  if (!boostPath) {
    dependsOn(downloadBoost)
  }
  dependsOn(downloadDoubleConversion)
  dependsOn(downloadFolly)
  dependsOn(downloadGlog)
}

/**
 * Finds the path of the installed npm package with the given name using Node's
 * module resolution algorithm, which searches "node_modules" directories up to
 * the file system root. This handles various cases, including:
 *
 *   - Working in the open-source RN repo:
 *       Gradle: /path/to/react-native/ReactAndroid
 *       Node module: /path/to/react-native/node_modules/[package]
 *
 *   - Installing RN as a dependency of an app and searching for hoisted
 *     dependencies:
 *       Gradle: /path/to/app/node_modules/react-native/ReactAndroid
 *       Node module: /path/to/app/node_modules/[package]
 *
 *   - Working in a larger repo (e.g., Facebook) that contains RN:
 *       Gradle: /path/to/repo/path/to/react-native/ReactAndroid
 *       Node module: /path/to/repo/node_modules/[package]
 *
 * The search begins at the given base directory (a File object). The returned
 * path is a string.
 */
def findNodeModulePath(baseDir, packageName) {
  def basePath = baseDir.toPath().normalize()
  // Node's module resolution algorithm searches up to the root directory,
  // after which the base path will be null
  while (basePath) {
    def candidatePath = Paths.get(basePath.toString(), "node_modules", packageName)
    if (candidatePath.toFile().exists()) {
      return candidatePath.toString()
    }
    basePath = basePath.getParent()
  }
  return null
}

def getNdkBuildName() {
  if (Os.isFamily(Os.FAMILY_WINDOWS)) {
    return "ndk-build.cmd"
  } else {
    return "ndk-build"
  }
}

def findNdkBuildFullPath() {
  // android.ndkDirectory should return project.android.ndkVersion ndkDirectory
  def ndkDir = android.ndkDirectory ? android.ndkDirectory.absolutePath : null
  if (ndkDir) {
    return new File(ndkDir, getNdkBuildName()).getAbsolutePath()
  }

  // we allow to provide full path to ndk-build tool
  if (hasProperty("ndk.command")) {
    return property("ndk.command")
  }
  // or just a path to the containing directory
  if (hasProperty("ndk.path")) {
    ndkDir = property("ndk.path")
    return new File(ndkDir, getNdkBuildName()).getAbsolutePath()
  }

  // @TODO ANDROID_NDK && ndk.dir is deprecated and will be removed in the future.
  if (System.getenv("ANDROID_NDK_HOME") != null) {
    ndkDir = System.getenv("ANDROID_NDK_HOME")
    return new File(ndkDir, getNdkBuildName()).getAbsolutePath()
  }

  // Left for the legacy reasons, use the previous one.
  if (System.getenv("ANDROID_NDK") != null) {
    ndkDir = System.getenv("ANDROID_NDK")
    return new File(ndkDir, getNdkBuildName()).getAbsolutePath()
  }

  return null
}

def getNdkBuildFullPath() {
  def ndkBuildFullPath = findNdkBuildFullPath()
  if (ndkBuildFullPath == null) {
    throw new GradleScriptException(
        "ndk-build binary cannot be found, check if you've set " +
            "\$ANDROID_NDK_HOME environment variable correctly or if ndk.dir is " +
            "setup in local.properties",
        null)
  }
  if (!new File(ndkBuildFullPath).canExecute()) {
    throw new GradleScriptException(
        "ndk-build binary " + ndkBuildFullPath + " doesn't exist or isn't executable.\n" +
            "Check that the \$ANDROID_NDK_HOME environment variable, or ndk.dir in local.properties, is set correctly.\n" +
            "(On Windows, make sure you escape backslashes in local.properties or use forward slashes, e.g. C:\\\\ndk or C:/ndk rather than C:\\ndk)",
        null)
  }
  return ndkBuildFullPath
}

def getCmakeToolchainFile() {
  return "-DCMAKE_TOOLCHAIN_FILE=${getNdkBuildFullPath()}/../build/cmake/android.toolchain.cmake"
}

// Create Android.mk library module based on jsc from npm
task prepareJSC {
  doLast {
    def jscPackagePath = findNodeModulePath(projectDir, "jsc-android")
    if (!jscPackagePath) {
      throw new GradleScriptException("Could not find the jsc-android npm package", null)
    }

    def jscDist = file("$jscPackagePath/dist")
    if (!jscDist.exists()) {
      throw new GradleScriptException("The jsc-android npm package is missing its \"dist\" directory", null)
    }

    def jscAAR = fileTree(jscDist).matching({ it.include "**/android-jsc/**/*.aar" }).singleFile
    def soFiles = zipTree(jscAAR).matching({ it.include "**/*.so" })

    def headerFiles = fileTree(jscDist).matching({ it.include "**/include/*.h" })

    copy {
      from(soFiles)
      from(headerFiles)
      from("$reactNative/ReactAndroid/src/main/jni/third-party/jsc/Android.mk")

      filesMatching("**/*.h", { it.path = "JavaScriptCore/${it.name}" })

      includeEmptyDirs(false)
      into("$thirdPartyNdkDir/jsc")
    }
  }
}

task extractAARHeaders {
  doLast {
    configurations.extractHeaders.files.each {
      def file = it.absoluteFile
      def packageName = file.name.tokenize('-')[0]
      copy {
        from zipTree(file)
        into "$reactNative/ReactAndroid/src/main/jni/first-party/$packageName/headers"
        include "**/*.h"
      }
    }
  }
}

task extractSOFiles {
  doLast {
    println "extractSOFiles"
    configurations.extractSO.files.each {
      def file = it.absoluteFile
      println file
      def packageName = file.name.tokenize('-')[0]
      copy {
        from zipTree(file)
        into "$reactNative/ReactAndroid/src/main/jni/first-party/$packageName/"
        include "jni/**/*.so"
      }
    }
  }
}

project.afterEvaluate {
  def nativeBuildTask = tasks.findByName("copyUnversionedReleaseJniLibsProjectAndLocalJars")  // for expoview
                        ?: tasks.findByName("copyReleaseJniLibsProjectAndLocalJars") // for expoview-${abiName}
  if (nativeBuildTask) {
    packageNdkLibs.dependsOn nativeBuildTask
  }

  // Workaround for AGP 7 local lint aar task with errors from a library project owning other aars.
  // In our case, it's the expoview (library project) owning hermes aar
  // ```
  // Error while evaluating property 'hasLocalAarDeps' of task ':expoview:bundleVersionedReleaseLocalLintAar'
  //   > Direct local .aar file dependencies are not supported when building an AAR.
  //     The resulting AAR would be broken because the classes and Android resources from any local .aar file dependencies would not be packaged in the resulting AAR.
  //     Previous versions of the Android Gradle Plugin produce broken AARs in this case too (despite not throwing this error).
  //     The following direct local .aar file dependencies of the :expoview project caused this error:
  //     /home/runner/work/expo/expo/node_modules/hermes-engine/android/hermes-release.aar
  // ```
  // For the workaround, we just pretend we don't have local aar dependencies.
  tasks.findByName("bundleVersionedReleaseLocalLintAar")?.localAarDeps?.setFrom([])
  tasks.findByName("bundleUnversionedReleaseLocalLintAar")?.localAarDeps?.setFrom([])
}

task packageNdkLibs(type: Copy) {
  from("$buildDir/intermediates/stripped_native_libs/unversionedRelease/out/lib") // for expoview
  from("$buildDir/intermediates/stripped_native_libs/release/out/lib") // for expoview-${abiName}
  include("**/libreanimated*.so")
  into("$projectDir/src/main/jniLibs")
}

task prepareThirdPartyNdkHeaders(dependsOn: [downloadNdkBuildDependencies, prepareBoost, prepareDoubleConversion, prepareFolly, prepareGlog]) {
}


// pre-native build pipeline

tasks.whenTaskAdded { task ->
  if (!task.name.contains("Clean") && (task.name.contains('externalNativeBuild') || task.name.startsWith('configureCMake'))) {
    def buildType = task.name.endsWith('Debug') ? 'Debug' : 'Release'
    task.dependsOn(prepareThirdPartyNdkHeaders)
    extractAARHeaders.dependsOn(prepareThirdPartyNdkHeaders)
    extractSOFiles.dependsOn(prepareThirdPartyNdkHeaders)
    task.dependsOn(extractAARHeaders)
    task.dependsOn(extractSOFiles)
    task.dependsOn(":ReactAndroid:copy${buildType}JniLibsProjectOnly")
  } else if (task.name.startsWith('generateJsonModel')) {
    def buildType = task.name.endsWith('Debug') ? 'Debug' : 'Release'
    task.dependsOn(":ReactAndroid:copy${buildType}JniLibsProjectOnly")
  }
}

// WHEN_PREPARING_REANIMATED_REMOVE_TO_HERE
